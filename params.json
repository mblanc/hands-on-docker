{"name":"Hands-on-docker","tagline":"","body":"Hands-on Docker\r\n======\r\n\r\nDans ce Hands-on, vous aurez à votre disposition une instance amazon où Docker a été préinstallé :\r\n\r\n1. ec2-54-217-152-153.eu-west-1.compute.amazonaws.com\r\n2. ec2-176-34-89-91.eu-west-1.compute.amazonaws.com\r\n3. ec2-54-228-48-40.eu-west-1.compute.amazonaws.com\r\n4. ec2-54-216-68-127.eu-west-1.compute.amazonaws.com\r\n5. ec2-54-228-175-232.eu-west-1.compute.amazonaws.com\r\n6. ec2-54-220-119-144.eu-west-1.compute.amazonaws.com\r\n7. ec2-54-217-186-173.eu-west-1.compute.amazonaws.com\r\n8. ec2-46-137-130-130.eu-west-1.compute.amazonaws.com\r\n9. ec2-54-217-79-220.eu-west-1.compute.amazonaws.com\r\n10. ec2-54-220-242-201.eu-west-1.compute.amazonaws.com\r\n11. ec2-54-220-246-217.eu-west-1.compute.amazonaws.com\r\n12. ec2-54-220-48-12.eu-west-1.compute.amazonaws.com\r\n13. ec2-54-247-139-133.eu-west-1.compute.amazonaws.com\r\n14. ec2-176-34-75-66.eu-west-1.compute.amazonaws.com\r\n15. ec2-54-220-59-92.eu-west-1.compute.amazonaws.com\r\n16. ec2-54-217-75-88.eu-west-1.compute.amazonaws.com\r\n17. ec2-54-220-251-131.eu-west-1.compute.amazonaws.com\r\n18. ec2-54-246-19-140.eu-west-1.compute.amazonaws.com\r\n\r\nToutes les machines utilisent la même clef ssh, et ont le même login **ubuntu**.\r\n\r\nPour vous connecter aux machines, récupérer le fichier docker.pem. N'oubliez pas de changer les permissions sur le fichier :\r\n\r\n\tchmod 600 docker.pem\r\n\r\nPour tester l'installation, et vous connecter à la première instance, taper la commande :\r\n\r\n\tssh -i docker.pem ubuntu@ec2-XX-XXX-XX-XXX.eu-west-1.compute.amazonaws.com\r\n\t\r\nPour éviter d'avoir à taper sudo avant chaque commande, démarrer un nouveau shell en tant que root:\r\n\r\n\tsudo -s\r\n\t\r\n\t\r\nTout au long de ce Hands-On, consultez [la Documentation en ligne de Docker](http://docs.docker.io/en/latest/) et n'hésitez pas pour chaque commande docker à lancer:\r\n\r\n\tdocker <command> --help\r\n\t\r\npour lister et tester les différentes options de chaque commande.\r\n\t\r\n## Premiers pas\r\n\r\nInstallez Docker c'est facile:\r\n\r\n\t# ne lancez pas cette commande docker est déjà installé sur votre serveur\r\n\tcurl http://get.docker.io | sh\r\n\r\n\r\nVérifiez que docker tourne en version 0.7.0\r\n\r\n\tdocker version\r\n\r\nListez les images docker présentes sur le serveur avec la commande:\r\n\r\n\tdocker images\r\n\t\r\nbusybox est une image docker basée sur [Busybox](http://www.busybox.net/about.html) (pour allez vite, une distrib linux qui tient sur une disquette). Nous allons chercher une image de base un peu plus utile. \r\n\r\nVous pouvez directement rechercher une image dans [le repo central de Docker](https://index.docker.io/) avec la commande:\r\n\r\n\tdocker search <search> \r\n\t# rechercher ubuntu -> pour l'instant c'est un peu le bordel\r\n\t\r\nTéléchargez l'image basée sur ubuntu créée par Docker Inc. (les images avec un nom simple sont celles créées par Docker Inc. les images créées par la communauté ont un nom du type namespace/name)\r\n\r\n\tdocker pull ubuntu\r\n\r\nLancez un conteneur docker qui execute un process simple:\r\n\r\n\tdocker run ubuntu echo hello, world\r\n\t\r\nQue c'est il passé?\r\n\r\n* création d'un conteneur lxc\r\n* allocation d'un file system pour ce dernier\r\n* montage d'un layer read-write\r\n* allocation d'une interface réseau\r\n* allocation d'une IP à ce conteneur\r\n* execute le process dans ce conteneur\r\n* capture stdout/stderr et vous l'imprime à l'écran\r\n\r\nréexecutez la dernière commande plusieurs fois de suite et appréciez la rapidité avec laquelle tout ceci est effectué (imaginez la même chose avec des VMs...)\r\n\r\nVérifiez les conteneurs docker qui tournent en ce moment sur le serveur:\r\n\r\n\tdocker ps\r\n\t\r\nIl n'y en a pas, c'est normal, le conteneur docker s'arrête en même temps que le processus unique qu'il execute.\r\n\r\nVérifiez les conteneurs docker qui ont tourné sur le serveur:\r\n\r\n\tdocker ps -a\r\n\r\n### Mode détaché\r\n\r\nCette fois ci, lancez un process \"long\" dans une conteneur en mode détaché (~mode daemon)\r\n\r\n\tCONTAINER_ID=$(docker run -d -t ubuntu /bin/sh -c \"while true; do echo hello world; sleep 1; done\")\r\n\t\r\nVérifiez que le conteneur tourne bien:\r\n\r\n\tdocker ps\r\n\t\r\nVoir le contenu récent de stdout/stderr du conteneur:\r\n\t\r\n\tdocker logs $CONTAINER_ID\r\n\t\r\nVous pouvez vous \"rattacher\" au conteneur (Ctrl+C pour se \"détacher\"):\r\n\t\r\n\tdocker attach $CONTAINER_ID\r\n\t\r\nArrêtez le conteneur\r\n\t\r\n\tdocker stop $CONTAINER_ID\r\n\t\r\n### Install, commit, test\r\n\r\nInatallez un nouveau package dans un conteneur:\r\n\r\n\tdocker run ubuntu apt-get install ping\r\n\t\r\nRécupérez l'identifiant du dernier conteneur:\r\n\t\r\n\tdocker ps -l\r\n\t\r\nCréez une image à partir de celui-ci (remplacer $USER par un identifiant du type première lettre de votre prénom+nom ou n'importe quoi de suffisament discriminant):\r\n\t\r\n\tdocker commit $CONTAINER_ID $USER/ping \r\n\t\r\nLancez un process dans un conteneur crée à partir de cette image:\r\n\t\r\n\tdocker run $USER/ping ping www.google.com\r\n\r\nRécupérez les données du conteneur:\r\n\t\r\n\tdocker inspect $CONTAINER_ID\r\n\t\r\nRécupérez l'IP du conteneur\r\n\t\r\n\tdocker inspect $CONTAINER_ID | grep IPAddress | cut -d '\"' -f 4\r\n\t\r\n(facultatif) ou avec [jq](http://stedolan.github.io/jq/)\r\n\r\ninstaller jq:\r\n\r\n\twget http://stedolan.github.io/jq/download/linux64/jq\r\n\tmkdir –p ~/bin\r\n\tmv jq ~/bin \r\n\texport PATH=$PATH:~/bin\r\n\tchmod +x ~/bin/jq\r\n\r\npuis\r\n\r\n\t$ docker inspect $CONTAINER_ID | jq -r '.[0].NetworkSettings.IPAddress'\t\r\n\r\n## Créer un conteneur Docker\r\n\r\n### Créer une image de manière interactive:\r\n\r\nLancer le process bash dans un conteneur en mode interactif:\r\n\r\n\tdocker run -i -t ubuntu:12.10 bash\r\n\t\r\nVous avez désomais un prompt bash au sein du conteneur.\r\nDans le conteneur, mettre à jour les packages:\r\n\r\n\tapt-get update\r\n\t\r\nInstaller redis:\r\n\r\n\tapt-get install redis-server\r\n\t\r\nQuitter le conteneur (et donc l'arrêter):\r\n\t\r\n\texit\r\n\t\r\nDe la même façon que dans le chapitre précedent, récupérer l'identifiant du conteneur et créer une image:\r\n\r\n\tdocker ps -a\r\n\tdocker commit $CONTAINER_ID $USER/redis01\r\n\t\r\n## Exposer un port du conteneur au serveur hôte\r\n\t\r\nLancer votre image:\r\n\r\n\tdocker run -p 6379 -d -i -t $USER/redis01 /usr/bin/redis-server\r\n\t\r\n-p 6379 pour exposer le port 6379 du conteneur, docker va mapper un port non utilisé (entre 449000 et 49900) de l'hôte sur le port 6379 du conteneur.\r\n\t\r\nrécupérer l'IP et le port exposé par le conteneur avec *docker ps* ou\r\n\t\r\n\tCONTAINER_ID=$(docker ps -l -q)\r\n\tID=$(docker inspect $CONTAINER_ID | grep IPAddress | cut -d '\"' -f 4)\r\n\tPORT=$(docker inspect $CONTAINER_ID | grep HostPort | cut -d '\"' -f 4)\r\n\t\r\nUn petit peu de redis pour tester:\r\n\r\n\ttelnet $IP 6379\r\n\t# OU\r\n\ttelnet localhost $PORT\r\n\tConnected to ???.\r\n\tEscape character is '^]'.\r\n    > rpush users jean\r\n    > rpush users paul\r\n    > rpush users jacques\r\n    > llen users\r\n\t3\r\n    > lrange users 0 5\r\n\tjean paul jacques\r\n\t\r\n\r\n### Créer une image à partir d'un fichier Dockerfile\r\n\r\nCréez la même image, cette fois ci de manière automatisée.\r\nVoir la documentation de Docker pour les fichiers Dockerfile.\r\nCréer dans un répertoire dédié un ficher **Dockerfile** dans lequel se trouvera:\r\n\r\n\t# redis image\r\n\t# VERSION 0.1\r\n\r\n\tFROM ubuntu:12.10\r\n\tMAINTAINER John Doe\r\n\r\n\tRUN apt-get -qq update\r\n\tRUN apt-get install -y redis-server\r\n\r\n\tEXPOSE 6379\r\n\tCMD [\"/usr/bin/redis-server\"]\r\n\t\r\nVous pouvez créer une image et la taguer en une seule commande à partir de ce fichier.\r\nDans le répertoire, lancer la commande:\r\n\r\n\tdocker build -t $USER/redis-dockerfile .\r\n\t\r\nPour lancer un conteneur à partir de cette image :\r\n\r\n\tdocker run -d -t $USER/redis-dockerfile\r\n\t\r\n### Rajoutons en une couche\r\n\r\nDans un nouveau répertoire dédié, nous allons créer une image docker à partir de la précedente.\r\nDans un fichier **fixtures.sh** écrivez:\r\n\r\n\t#!/bin/bash\r\n\r\n\t/usr/bin/redis-server &\r\n\tfor ((i=1; i <=100; i++))\r\n\tdo\r\n    \tredis-cli rpush numbers $i\r\n\tdone\r\n\tredis-cli shutdown\r\n\t\r\nDans le fichier **Dockerfile** écrivez:\r\n\r\n\tFROM $USER/redis-dockerfile\r\n\tMAINTAINER John Doe\r\n\r\n\tADD fixtures.sh /tmp/fixtures.sh\r\n\tRUN /tmp/fixtures.sh\r\n\t\r\nCréez une deuxième version de votre serveur redis \"dockerizé\" prérempli de quelques données:\r\n\r\n\tdocker build -t $USER/redis-dockerfile2 .\r\n\r\n### Names and links: comment les conteneurs se parlent sans être exposé au monde exterieur.\r\n\r\nLancez un conteneur à partir de l'image créée précedemment et attribuez lui un nom:\r\n\r\n\r\n\tdocker run -d -t -name redis $USER/redis-dockerfile2\t\r\nLancer une conteneur qui fera office de client de votre serveur redis:\r\n\r\n\tdocker run -i -t -link redis:redis mblanc/redis01 bash\r\n\t\r\nDans le prompt bash de votre conteneur, entrez:\r\n\r\n\tenv\r\n\t\r\nUn certain nombre de variables d'environnement ont été ajoutées au conteneur pour facilement retrouver des infos sur le conteneur faisant tourner le serveur redis.\r\nConnectez vous à celui-ci et testez que tout marche bien:\r\n\t\r\n\tredis-cli -h $REDIS_PORT_6379_TCP_ADDR -p $REDIS_PORT_6379_TCP_PORT\r\n\tredis > lrange numbers 0 5\r\n\t1) \"2\"\r\n\t2) \"3\"\r\n\t3) \"4\"\r\n\t4) \"5\"\r\n\t5) \"6\"\r\n\t6) \"7\"\r\n\t\r\n\r\n### Le docker index c'est cool\r\n\r\nVous avez déjà essayé d'installer IPython sur une machine? C'est très, très penible.\r\nPlus maintenant avec docker:\r\n\r\n\tdocker pull crosbymichael/ipython\r\n\tdocker run -d -p 80:8888 crosbymichael/ipython\r\n\t\r\nEntrez l'url de votre instance ec2 dans votre browser préféré -> et voilà!\r\n\r\n## Bonus point\r\n\r\nvous pouvez voir l'arborescence de vos conteneurs docker à l'aide des commandes:\r\n\t\r\n\tapt-get install graphviz\r\n\tdocker images -viz | dot -Tpng -o docker.png\r\n\tpython -m SimpleHTTPServer 80\r\n\t\r\nEntrez l'url de votre instance ec2 dans votre browser préféré\r\n\r\n## Exercice\r\n\r\n1. En vous appuyant sur [la doc de MongoDB](http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/), créez une image docker qui fera tourner une instance mongo.\r\n\r\n\tAttention: mongodb a besoin de initctl qui n'est pas présent dans ubuntu, vous devrez \tajoutez ces commandes dans votre Dockerfile:\r\n\r\n\tRUN dpkg-divert --local --rename --add /sbin/initctl\r\n\tRUN ln -s /bin/true /sbin/initctl\r\n\t\r\n\tSolution : [https://github.com/mblanc/hands-on-docker/blob/master/mongo/Dockerfile](https://github.com/mblanc/hands-on-docker/blob/master/mongo/Dockerfile)\r\n\t\r\n2. En vous appuyant sur [la doc de joyent](https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager), créez un conteneur qui lancera l'application suivante https://github.com/mblanc/express-todo-example dans un serveur node.js.\r\n\r\n\t(installez git ```apt-get install git``` clonez l'application ```git clone https://github.com/mblanc/express-todo-example.git``` ajoutez l'application dans votre conteneur à l'aide de la commande ADD dans votre Dockerfile)\r\n\r\n\tAttention: vous devrez modifier le fichier db.js pour que l'application se connecte au serveur mongo du premier conteneur)\r\n\r\n\tSolution: [https://github.com/mblanc/hands-on-docker/tree/master/express-todo-example](https://github.com/mblanc/hands-on-docker/tree/master/express-todo-example)\r\n\r\n\r\n3. Lancez votre conteneur mongo\r\n\r\n4. Lancez votre conteneur lancant l'application node.js avec un lien vers le conteneur mongo et mappant le port 80 du serveur ec2 vers le port 8888 de ce conteneur.\r\n\r\n5. Entrez l'url de votre instance ec2 dans votre browser préféré\r\n\r\n6. Profit","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}